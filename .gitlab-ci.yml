variables:
  REPO:
    value: "https://github.com/legleux/test_mirror.git"
    description: "Source repository."
  BRANCH:
    value: "main"
    description: "Branch to build."
  COMMIT_ID:
    value: ""
    description: "Specific commit to build."
  WORKFLOW_NAME:
    value: "Mirror update"
    description: "Default name of the workflow in the WebUI"
  DRY_RUN:
    description: "Don't push any artifacts."
    value: "--no-dry-run"
    options:
      - "--dry-run"
      - "--no-dry-run"
  COMPONENT:
    description: 'The repo "component" deployed to'
    value: "main"

  REGISTRY: "legleux"
  IMAGE_NAME: "$CI_PROJECT_NAME"
  IMAGE: ${REGISTRY}/${IMAGE_NAME}
  DOCKER_BUILDKIT: "1"
  DOCKER_TLS_CERTDIR: ""
  dpkg_image: "ghcr.io/xrplf/ci/debian-bookworm:gcc-12"
  rpm_image: "ghcr.io/xrplf/ci/rhel-9:gcc-12"
  image:
    value: "${${PKG}_image}"
    description: The Docker image to run the build in. ${PKG} is based on the parallel job, either "dpkg" or "rpm" which is mapping to ${dpkg_container} and ${rpm_container} what about ${dpkg_image_tag}

workflow:
  name: "$WORKFLOW_NAME"

.pkg_rule:
  image:
    name: ${build_image}
    entrypoint: [""]
  rules:
    - if: >
        $CI_PROJECT_NAME == "pipeline" &&
        $CI_PIPELINE_SOURCE =~ /^(pipeline|web)$/ &&
        (
          $UPSTREAM_BRANCH == "main" ||
          $UPSTREAM_BRANCH =~ /^release-\d+$/ ||
          $UPSTREAM_CI_COMMIT_TAG =~ /^\d+\.\d+\.\d+(?:-(?:b|rc)\d+)?$/
        )

stages:
  - trigger
  - build_packages
  # - build_images
  # - push_image
  # - push_packages

.dind_template: &dind_param
  before_script: |
    echo "$DOCKER_PAT" | docker login -u "$DOCKER_USER" --password-stdin
  variables:
    docker_driver: overlay2
    DOCKER_TLS_CERTDIR: ""
  image:
    name: docker:latest
  services:
    - name: docker:stable-dind
      alias: docker

trigger_package_build:
  stage: trigger
  rules:
    - if: $CI_PROJECT_NAME != "pkg_build"
      when: never
    - if: $CI_COMMIT_TAG =~ /^\d+\.\d+\.\d+(?:-(?:b|rc)\d+
      variables:
        WORKFLOW_NAME: "$CI_COMMIT_TAG - $CI_COMMIT_SHORT_SHA"
    - if: $CI_COMMIT_BRANCH == "main"
      variables:
        WORKFLOW_NAME: "$CI_COMMIT_BRANCH - $CI_COMMIT_SHORT_SHA"
  variables:
    UPSTREAM_PROJECT: $CI_PROJECT_NAME
    UPSTREAM_SHA: $CI_COMMIT_SHA
    UPSTREAM_SHORT_SHA: $CI_COMMIT_SHORT_SHA
    UPSTREAM_BRANCH: $CI_COMMIT_BRANCH
    UPSTREAM_CI_COMMIT_TAG: $CI_COMMIT_TAG
  trigger:
    project: ripple/xrpledger/pipeline
    strategy: depend

build_packages:
  extends: .pkg_rule
  # image:
  #   name: ${build_image}
  #   entrypoint: [""]
  stage: build_packages
  script: |
    echo "*******************************************"
    echo "UPSTREAM_PROJECT: $UPSTREAM_PROJECT"
    echo "UPSTREAM_SHA: $UPSTREAM_SHA"
    echo "UPSTREAM_BRANCH: $UPSTREAM_BRANCH"
    echo "UPSTREAM_CI_COMMIT_TAG: $UPSTREAM_CI_COMMIT_TAG"
    echo "*******************************************"
    echo "CI_PROJECT_NAME: $CI_PROJECT_NAME"
    echo "CI_COMMIT_SHA: $CI_COMMIT_SHA"
    echo "CI_COMMIT_BRANCH: $CI_COMMIT_BRANCH"
    echo "CI_COMMIT_TAG: $CI_COMMIT_TAG"
    echo "*******************************************"

    BRANCH="${UPSTREAM_CI_COMMIT_TAG:-$UPSTREAM_BRANCH}"
    export FORCE_CLIO_VERSION=${BRANCH}
    export GITHUB_HEAD_SHA="$UPSTREAM_SHA"

    # git clone --depth 1 --branch

  # artifacts:
  #   paths:
  #     - build/${PKG}-${ARCH}/packages
  #     - image_bins/
  #   reports:
  #       dotenv: build.env
  # parallel:
  #   matrix:
  #     - ARCH: amd
  #       RUNNER_TAG: docker-4xlarge
  #       PKG: rpm
  #       PKG_TYPE: rpm
  #     - ARCH: arm
  #       RUNNER_TAG: arm
  #       PKG: rpm
  #       PKG_TYPE: rpm
  #     - ARCH: amd
  #       RUNNER_TAG: docker-4xlarge
  #       PKG: dpkg
  #       PKG_TYPE: deb
  #     - ARCH: arm
  #       RUNNER_TAG: arm
  #       PKG: dpkg
  #       PKG_TYPE: deb
  # tags:
  #   - ${RUNNER_TAG}

# build_image:
#   stage: build_images
#   needs:
#     - job: get_git_info
#       artifacts: true
#   <<: *dind_param
#   script: |
#     set -ex
#     apk add --no-cache \
#       bash \
#       busybox-extras \
#       coreutils \
#       jq \
#         >/dev/null
#     echo "== env DOCKER_* =="
#     env | grep -E '^DOCKER' || true

#     echo "== resolve docker =="
#     getent hosts docker || true

#     echo "== probe ports =="

#     nc -zv docker 2375 || true
#     nc -zv docker 2376 || true

#     echo "== docker context/endpoints =="
#     docker context ls || true
#     docker context inspect default --format '{{json .Endpoints}}' || true

#     echo "== docker version/info =="
#     docker version --format 'client={{.Client.APIVersion}} server={{.Server.APIVersion}}' || true
#     docker info || true
#     getent hosts docker || true
#     nc -zv docker 2375 || true
#     docker info
#     docker version --format 'client={{.Client.APIVersion}} server={{.Server.APIVersion}}'
#     echo "CI_COMMIT_SHA: $CI_COMMIT_SHA"
#     echo "CI_COMMIT_REF_NAME: $CI_COMMIT_REF_NAME"
#     echo "CI_COMMIT_BRANCH: $CI_COMMIT_BRANCH"
#     echo "CI_COMMIT_TAG: $CI_COMMIT_TAG"
#     echo "CI_COMMIT_TIMESTAMP: $CI_COMMIT_TIMESTAMP"
#     echo "CI_PIPELINE_NAME: $CI_PIPELINE_NAME"
#     echo "CI_PIPELINE_SOURCE: $CI_PIPELINE_SOURCE"
#     echo "GITLAB_CI: $GITLAB_CI"
#     echo "CI_COMMIT_REF_PROTECTED: $CI_COMMIT_REF_PROTECTED"
#     echo "CI_COMMIT_REF_SLUG: $CI_COMMIT_REF_SLUG"
#     echo "CI_COMMIT_SHORT_SHA: $CI_COMMIT_SHORT_SHA"
#     echo "CI_COMMIT_TITLE: $CI_COMMIT_TITLE"
#     #####
#     echo "CI_UPSTREAM_PROJECT_ID: $CI_UPSTREAM_PROJECT_ID"
#     echo "CI_UPSTREAM_JOB_ID: $CI_UPSTREAM_JOB_ID"
#     echo "CI_UPSTREAM_PIPELINE_ID: $CI_UPSTREAM_PIPELINE_ID"
#     #####
#     echo "CI_DEFAULT_BRANCH: $CI_DEFAULT_BRANCH"
#     echo "CI_DEFAULT_BRANCH_SLUG: $CI_DEFAULT_BRANCH_SLUG"
#     echo "CI_JOB_ID: $CI_JOB_ID"
#     echo "CI_JOB_IMAGE: $CI_JOB_IMAGE"
#     echo "CI_JOB_MANUAL: $CI_JOB_MANUAL"
#     echo "CI_JOB_NAME_SLUG: $CI_JOB_NAME_SLUG"
#     echo "CI_JOB_STAGE: $CI_JOB_STAGE"
#     ls -l
#     . ./build.env
#     echo "git_hash=${git_hash}"
#     echo "branch=${branch}"
#     if [ -n "${git_tag}" ]; then
#         echo "git_tag=$git_tag"
#     fi

#     export PUSH=true
#     pwd
#     ls -la
#     cd ./push_docker_image
#     pwd
#     ls -la
#     ls -la ../Dockerfile
#     . ./build_image.sh
#     cd ..
#     ls -l
#     find . -name "Dockerfile.*"
#     export DOCKER_BUILDKIT
#     docker buildx version
#     docker buildx ls
#     ./build_docker_image.sh
#   parallel:
#     matrix:
#       - ARCH: amd
#         RUNNER_TAG: docker-4xlarge
#       - ARCH: arm
#         RUNNER_TAG: arm
#   tags:
#     - ${RUNNER_TAG}

# merge_manifests:
#   stage: push_image
#   <<: *dind_param
#   dependencies:
#     - get_git_info
#   script: |
#     apk add curl jq
#     set -x
#     cat build.env
#     . ./build.env

#     echo "git_hash=${git_hash}"
#     echo "branch=${branch}"
#     echo "git_tag=${git_tag}"

#     manifest_list=${IMAGE}:${git_hash}
#     docker manifest create ${manifest_list} \
#       --amend ${manifest_list}-amd64 \
#       --amend ${manifest_list}-arm64

#     docker manifest push ${manifest_list}
#     additional_tags="${branch}"

#     if [ "${branch}" = "master" ] || [ "${branch}" = "main" ]; then
#         additional_tags="$additional_tags latest"
#     fi
#     if [ -n "${git_tag}" ]; then
#         additional_tags="$additional_tags ${git_tag}"
#     fi
#     for t in $additional_tags
#     do
#         tag="${tag:+$tag} --tag $IMAGE:$t"
#     done

#     docker buildx imagetools create ${tag} ${manifest_list}

#     # Delete the arch specific tags
#     TOKEN=$(curl -s -H "Content-Type: application/json" -X POST -d "{\"username\": \"$DOCKER_USER\", \"password\": \"$DOCKER_PAT\"}" https://hub.docker.com/v2/users/login/ | jq -r .token)
#     for arch in amd arm; do
#       TAG=${git_hash}-${arch}64
#       curl -v -H "Authorization: JWT ${TOKEN}" -X DELETE https://hub.docker.com/v2/repositories/${REGISTRY}/${IMAGE_NAME}/tags/${TAG}/
#     done
